"""
Trading Automation Engine
Handles the complete trade approval workflow and automated execution
"""
import logging
from decimal import Decimal
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from django.utils import timezone
from django.db import transaction
from django.contrib.auth import get_user_model

from .models import (
    TradingSignal, TradingOrder, TradingStrategy, TradeApproval,
    AutomatedTradeExecution, PortfolioPosition
)
from apps.brokers.models import BrokerAccount
from apps.brokers.services import BrokerService

User = get_user_model()
logger = logging.getLogger(__name__)


class TradingAutomationEngine:
    """
    Core automation engine for ShareWise AI trading system
    Implements the PDF requirements:
    - Trade approval flow: Notify user → Confirm → Execute
    - Automated trade management (SL, Target, Time-based exit)
    - Broker selection for trades
    """
    
    def __init__(self):
        self.broker_service = BrokerService()
        
    def process_new_signal(self, signal: TradingSignal) -> Dict[str, any]:
        """
        Process a new trading signal through the automation workflow
        
        Args:
            signal: TradingSignal instance
            
        Returns:
            Dict with processing results
        """
        try:
            # Find applicable strategies for this signal
            strategies = self._find_applicable_strategies(signal)
            
            if not strategies:
                logger.info(f"No applicable strategies found for signal {signal.id}")
                return {"status": "no_strategies", "signal_id": str(signal.id)}
            
            results = []
            for strategy in strategies:
                result = self._process_signal_for_strategy(signal, strategy)
                results.append(result)
            
            return {
                "status": "processed",
                "signal_id": str(signal.id),
                "strategies_processed": len(strategies),
                "results": results
            }
            
        except Exception as e:
            logger.error(f"Error processing signal {signal.id}: {e}")
            return {"status": "error", "error": str(e)}
    
    def _find_applicable_strategies(self, signal: TradingSignal) -> List[TradingStrategy]:
        """Find active strategies that should process this signal"""
        # Get all active strategies for the signal's user
        strategies = TradingStrategy.objects.filter(
            user=signal.user,
            status=TradingStrategy.Status.ACTIVE
        )
        
        # Filter by ML model if signal was generated by specific model
        if signal.created_by_strategy_id:
            strategies = strategies.filter(
                ml_model__id=signal.created_by_strategy_id
            )
        
        # Additional filtering based on instrument type, risk limits, etc.
        applicable_strategies = []
        for strategy in strategies:
            if self._is_strategy_applicable(strategy, signal):
                applicable_strategies.append(strategy)
        
        return applicable_strategies
    
    def _is_strategy_applicable(self, strategy: TradingStrategy, signal: TradingSignal) -> bool:
        """Check if strategy should process this signal"""
        # Check if strategy has available broker account
        if not strategy.assigned_broker_account:
            return False
        
        # Check position size limits
        position_value = signal.entry_price * Decimal('100')  # Assume 100 shares default
        if position_value > strategy.max_position_size:
            return False
        
        # Check daily loss limits
        today_pnl = self._get_strategy_daily_pnl(strategy)
        if today_pnl <= -strategy.max_daily_loss:
            return False
        
        # Check open positions limit
        open_positions = self._get_open_positions_count(strategy)
        if open_positions >= strategy.max_open_positions:
            return False
        
        return True
    
    def _process_signal_for_strategy(self, signal: TradingSignal, strategy: TradingStrategy) -> Dict[str, any]:
        """Process a signal for a specific strategy"""
        try:
            with transaction.atomic():
                if strategy.auto_execute:
                    # Auto-execute without approval
                    return self._execute_signal_automatically(signal, strategy)
                else:
                    # Require user approval
                    return self._create_approval_request(signal, strategy)
                    
        except Exception as e:
            logger.error(f"Error processing signal {signal.id} for strategy {strategy.id}: {e}")
            return {"status": "error", "strategy_id": str(strategy.id), "error": str(e)}
    
    def _create_approval_request(self, signal: TradingSignal, strategy: TradingStrategy) -> Dict[str, any]:
        """Create trade approval request for user confirmation"""
        try:
            # Calculate proposed trade details
            proposed_quantity = self._calculate_position_size(signal, strategy)
            
            # Create approval request
            approval = TradeApproval.objects.create(
                signal=signal,
                user=signal.user,
                strategy=strategy,
                proposed_quantity=proposed_quantity,
                proposed_price=signal.entry_price,
                proposed_broker_account=strategy.assigned_broker_account,
                expires_at=timezone.now() + timedelta(minutes=30)  # 30 min expiry
            )
            
            # Send notification to user
            self._send_approval_notification(approval)
            
            logger.info(f"Created approval request {approval.id} for signal {signal.id}")
            
            return {
                "status": "approval_created",
                "approval_id": str(approval.id),
                "strategy_id": str(strategy.id),
                "expires_at": approval.expires_at.isoformat()
            }
            
        except Exception as e:
            logger.error(f"Error creating approval request: {e}")
            raise
    
    def approve_trade(self, approval_id: str, user_id: str, 
                     approved_quantity: Optional[int] = None,
                     approved_price: Optional[Decimal] = None) -> Dict[str, any]:
        """
        Approve a trade and execute it
        
        Args:
            approval_id: TradeApproval ID
            user_id: User ID for authorization
            approved_quantity: Override quantity (optional)
            approved_price: Override price (optional)
        """
        try:
            approval = TradeApproval.objects.select_related(
                'signal', 'strategy', 'user'
            ).get(id=approval_id, user_id=user_id)
            
            if approval.status != TradeApproval.Status.PENDING:
                return {"status": "error", "message": "Approval already processed"}
            
            if approval.is_expired:
                approval.status = TradeApproval.Status.EXPIRED
                approval.save()
                return {"status": "error", "message": "Approval expired"}
            
            # Update approval with user decisions
            approval.status = TradeApproval.Status.APPROVED
            approval.approved_quantity = approved_quantity or approval.proposed_quantity
            approval.approved_price = approved_price or approval.proposed_price
            approval.approved_at = timezone.now()
            approval.save()
            
            # Execute the trade
            execution_result = self._execute_approved_trade(approval)
            
            return {
                "status": "approved_and_executed",
                "approval_id": str(approval.id),
                "execution_result": execution_result
            }
            
        except TradeApproval.DoesNotExist:
            return {"status": "error", "message": "Approval not found"}
        except Exception as e:
            logger.error(f"Error approving trade {approval_id}: {e}")
            return {"status": "error", "message": str(e)}
    
    def reject_trade(self, approval_id: str, user_id: str, reason: str = "") -> Dict[str, any]:
        """Reject a trade approval"""
        try:
            approval = TradeApproval.objects.get(id=approval_id, user_id=user_id)
            
            if approval.status != TradeApproval.Status.PENDING:
                return {"status": "error", "message": "Approval already processed"}
            
            approval.status = TradeApproval.Status.REJECTED
            approval.rejection_reason = reason
            approval.save()
            
            return {"status": "rejected", "approval_id": str(approval.id)}
            
        except TradeApproval.DoesNotExist:
            return {"status": "error", "message": "Approval not found"}
        except Exception as e:
            logger.error(f"Error rejecting trade {approval_id}: {e}")
            return {"status": "error", "message": str(e)}
    
    def _execute_signal_automatically(self, signal: TradingSignal, strategy: TradingStrategy) -> Dict[str, any]:
        """Execute signal automatically without approval"""
        try:
            # Calculate position size
            quantity = self._calculate_position_size(signal, strategy)
            
            # Create execution record
            execution = AutomatedTradeExecution.objects.create(
                signal=signal,
                strategy=strategy,
                status=AutomatedTradeExecution.ExecutionStatus.QUEUED
            )
            
            # Execute the trade
            result = self._place_entry_order(execution, quantity, signal.entry_price)
            
            return {
                "status": "auto_executed",
                "execution_id": str(execution.id),
                "strategy_id": str(strategy.id),
                "result": result
            }
            
        except Exception as e:
            logger.error(f"Error in auto execution: {e}")
            raise
    
    def _execute_approved_trade(self, approval: TradeApproval) -> Dict[str, any]:
        """Execute an approved trade"""
        try:
            # Create execution record
            execution = AutomatedTradeExecution.objects.create(
                signal=approval.signal,
                strategy=approval.strategy,
                approval=approval,
                status=AutomatedTradeExecution.ExecutionStatus.QUEUED
            )
            
            # Execute the trade
            result = self._place_entry_order(
                execution, 
                approval.approved_quantity, 
                approval.approved_price
            )
            
            approval.status = TradeApproval.Status.EXECUTED
            approval.executed_at = timezone.now()
            approval.save()
            
            return result
            
        except Exception as e:
            logger.error(f"Error executing approved trade: {e}")
            raise
    
    def _place_entry_order(self, execution: AutomatedTradeExecution, 
                          quantity: int, price: Decimal) -> Dict[str, any]:
        """Place the entry order through broker API"""
        try:
            execution.status = AutomatedTradeExecution.ExecutionStatus.EXECUTING
            execution.save()
            
            signal = execution.signal
            strategy = execution.strategy
            
            # Create order record
            order = TradingOrder.objects.create(
                signal=signal,
                user=signal.user,
                symbol=signal.symbol,
                instrument_type=signal.instrument_type,
                order_type=TradingOrder.OrderType.LIMIT,
                transaction_type=signal.signal_type,
                quantity=quantity,
                price=price,
                underlying_symbol=signal.underlying_symbol,
                expiry_date=signal.expiry_date,
                strike_price=signal.strike_price,
                option_type=signal.option_type,
                target_price=signal.target_price,
                stoploss_price=signal.stop_loss
            )
            
            # Execute through broker API
            broker_result = self.broker_service.place_order(
                broker_account_id=strategy.assigned_broker_account,
                order=order
            )
            
            if broker_result.get('status') == 'success':
                order.broker_order_id = broker_result.get('order_id')
                order.status = TradingOrder.OrderStatus.OPEN
                order.save()
                
                execution.entry_order = order
                execution.entry_executed_at = timezone.now()
                execution.save()
                
                # Place stop loss and target orders if specified
                self._place_exit_orders(execution)
                
                # Update portfolio position
                self._update_portfolio_position(execution)
                
                execution.status = AutomatedTradeExecution.ExecutionStatus.COMPLETED
                execution.save()
                
                return {"status": "success", "order_id": str(order.id)}
            else:
                execution.status = AutomatedTradeExecution.ExecutionStatus.FAILED
                execution.error_message = broker_result.get('error', 'Unknown error')
                execution.save()
                
                return {"status": "failed", "error": execution.error_message}
                
        except Exception as e:
            execution.status = AutomatedTradeExecution.ExecutionStatus.FAILED
            execution.error_message = str(e)
            execution.save()
            raise
    
    def _place_exit_orders(self, execution: AutomatedTradeExecution):
        """Place stop loss and target orders"""
        try:
            signal = execution.signal
            strategy = execution.strategy
            
            # Place stop loss order
            if signal.stop_loss:
                sl_order = TradingOrder.objects.create(
                    signal=signal,
                    user=signal.user,
                    symbol=signal.symbol,
                    instrument_type=signal.instrument_type,
                    order_type=TradingOrder.OrderType.SL,
                    transaction_type=self._get_exit_transaction_type(signal.signal_type),
                    quantity=execution.entry_order.quantity,
                    trigger_price=signal.stop_loss,
                    price=signal.stop_loss
                )
                
                execution.stop_loss_order = sl_order
            
            # Place target order
            if signal.target_price:
                target_order = TradingOrder.objects.create(
                    signal=signal,
                    user=signal.user,
                    symbol=signal.symbol,
                    instrument_type=signal.instrument_type,
                    order_type=TradingOrder.OrderType.LIMIT,
                    transaction_type=self._get_exit_transaction_type(signal.signal_type),
                    quantity=execution.entry_order.quantity,
                    price=signal.target_price
                )
                
                execution.target_order = target_order
            
            execution.save()
            
        except Exception as e:
            logger.error(f"Error placing exit orders: {e}")
    
    def _update_portfolio_position(self, execution: AutomatedTradeExecution):
        """Update aggregated portfolio position"""
        try:
            signal = execution.signal
            order = execution.entry_order
            
            position, created = PortfolioPosition.objects.get_or_create(
                user=signal.user,
                symbol=signal.symbol,
                instrument_type=signal.instrument_type,
                defaults={
                    'position_type': 'LONG' if signal.signal_type in ['BUY', 'COVER'] else 'SHORT',
                    'total_quantity': 0,
                    'available_quantity': 0,
                    'average_price': Decimal('0.00'),
                    'broker_positions': {}
                }
            )
            
            # Update position quantities and average price
            if signal.signal_type in ['BUY', 'COVER']:
                new_total = position.total_quantity + order.quantity
                new_avg_price = ((position.average_price * position.total_quantity) + 
                               (order.price * order.quantity)) / new_total
                position.total_quantity = new_total
                position.available_quantity = new_total
                position.average_price = new_avg_price
            else:  # SELL, SHORT
                position.total_quantity -= order.quantity
                position.available_quantity = max(0, position.available_quantity - order.quantity)
            
            # Update broker allocation
            broker_id = execution.strategy.assigned_broker_account
            if broker_id not in position.broker_positions:
                position.broker_positions[broker_id] = {'quantity': 0, 'average_price': 0}
            
            broker_pos = position.broker_positions[broker_id]
            if signal.signal_type in ['BUY', 'COVER']:
                broker_pos['quantity'] += order.quantity
            else:
                broker_pos['quantity'] -= order.quantity
            
            position.save()
            
        except Exception as e:
            logger.error(f"Error updating portfolio position: {e}")
    
    def _calculate_position_size(self, signal: TradingSignal, strategy: TradingStrategy) -> int:
        """Calculate appropriate position size based on risk management"""
        # Simple position sizing - can be enhanced with more sophisticated algorithms
        max_risk_per_trade = strategy.max_position_size * Decimal('0.02')  # 2% risk
        
        if signal.stop_loss and signal.entry_price:
            risk_per_share = abs(signal.entry_price - signal.stop_loss)
            if risk_per_share > 0:
                max_shares = int(max_risk_per_trade / risk_per_share)
                return min(max_shares, 100)  # Cap at 100 shares
        
        # Default position size
        return min(int(strategy.max_position_size / signal.entry_price), 50)
    
    def _get_exit_transaction_type(self, entry_type: str) -> str:
        """Get the opposite transaction type for exit"""
        if entry_type == 'BUY':
            return 'SELL'
        elif entry_type == 'SELL':
            return 'BUY'
        elif entry_type == 'SHORT':
            return 'COVER'
        elif entry_type == 'COVER':
            return 'SHORT'
        return 'SELL'
    
    def _get_strategy_daily_pnl(self, strategy: TradingStrategy) -> Decimal:
        """Get today's P&L for a strategy"""
        today = timezone.now().date()
        executions = AutomatedTradeExecution.objects.filter(
            strategy=strategy,
            created_at__date=today
        )
        return sum(execution.total_pnl for execution in executions)
    
    def _get_open_positions_count(self, strategy: TradingStrategy) -> int:
        """Get count of open positions for a strategy"""
        return AutomatedTradeExecution.objects.filter(
            strategy=strategy,
            status=AutomatedTradeExecution.ExecutionStatus.COMPLETED
        ).filter(
            entry_order__status=TradingOrder.OrderStatus.COMPLETE,
            stop_loss_order__status__in=[
                TradingOrder.OrderStatus.PENDING, 
                TradingOrder.OrderStatus.OPEN
            ]
        ).count()
    
    def _send_approval_notification(self, approval: TradeApproval):
        """Send notification to user for trade approval"""
        # Placeholder for notification service
        # In real implementation, this would send email, SMS, or push notification
        logger.info(f"Sending approval notification for {approval.id} to {approval.user.email}")
        
        # Update notification status
        approval.notification_sent = True
        approval.save()


# Global instance
automation_engine = TradingAutomationEngine()


def process_trading_signal(signal: TradingSignal) -> Dict[str, any]:
    """Convenience function to process trading signals"""
    return automation_engine.process_new_signal(signal)


def approve_trade_request(approval_id: str, user_id: str, **kwargs) -> Dict[str, any]:
    """Convenience function to approve trade requests"""
    return automation_engine.approve_trade(approval_id, user_id, **kwargs)


def reject_trade_request(approval_id: str, user_id: str, reason: str = "") -> Dict[str, any]:
    """Convenience function to reject trade requests"""
    return automation_engine.reject_trade(approval_id, user_id, reason)